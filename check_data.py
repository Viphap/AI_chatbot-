# -*- coding: utf-8 -*-
"""Check_Data.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1eNOOlXO8SU7KS4K00Fzdqlau8rSF2U0s
"""

import requests
import pandas as pd
from datetime import datetime, timezone
from concurrent.futures import ThreadPoolExecutor
import getpass
import re

class NewsenseScanner:
    def __init__(self, base_url, user, password):
        self.base_url = base_url.rstrip('/')
        self.user = user
        self.password = password
        self.token = None
        self.login()

    def login(self):
        url = f"{self.base_url}/auth/login"
        try:
            resp = requests.post(url, json={"username": self.user, "password": self.password})
            resp.raise_for_status()
            self.token = resp.json()["token"]
            print("âœ… ÄÄƒng nháº­p Newsense thÃ nh cÃ´ng!")
        except Exception as e:
            print(f"âŒ ÄÄƒng nháº­p tháº¥t báº¡i: {e}")

    def get_all_devices(self):
        """Láº¥y táº¥t cáº£ thiáº¿t bá»‹ cÃ³ trong tÃ i khoáº£n."""
        headers = {"X-Authorization": f"Bearer {self.token}"}
        devices = []
        page = 0
        while True:
            url = f"{self.base_url}/tenant/devices?pageSize=100&page={page}"
            resp = requests.get(url, headers=headers)
            data = resp.json()
            for d in data.get("data", []):
                devices.append({"id": d["id"]["id"], "name": d["name"]})
            if not data.get("hasNextPage"):
                break
            page += 1
        return devices

    def get_device_keys(self, device_id):
        """Láº¥y táº¥t cáº£ cÃ¡c tÃªn biáº¿n (keys) cá»§a má»™t thiáº¿t bá»‹."""
        headers = {"X-Authorization": f"Bearer {self.token}"}
        url = f"{self.base_url}/plugins/telemetry/DEVICE/{device_id}/keys/timeseries"
        try:
            resp = requests.get(url, headers=headers)
            return resp.json() if resp.status_code == 200 else []
        except:
            return []

    def get_latest_telemetry(self, device_id, device_name, keys, time_delay_seconds):
        """Láº¥y timestamp má»›i nháº¥t cho táº¥t cáº£ keys cá»§a 1 thiáº¿t bá»‹."""
        if not keys: return []

        headers = {"X-Authorization": f"Bearer {self.token}"}
        keys_str = ",".join(keys)
        url = f"{self.base_url}/plugins/telemetry/DEVICE/{device_id}/values/timeseries?keys={keys_str}&limit=1"

        results = []
        try:
            resp = requests.get(url, headers=headers)
            data = resp.json()
            now = datetime.now(timezone.utc)

            for key in keys:
                if key in data and len(data[key]) > 0:
                    last_ts = data[key][0]['ts']
                    last_time = datetime.fromtimestamp(last_ts / 1000, tz=timezone.utc)
                    diff = now - last_time

                    # Tráº¡ng thÃ¡i dá»±a trÃªn sá»‘ giÃ¢y Ä‘Ã£ parse
                    status = "ðŸŸ¢ Active" if diff.total_seconds() < time_delay_seconds else "ðŸ”´ Stopped"

                    results.append({
                        "Device Name": device_name,
                        "Variable (Key)": key,
                        "Last Update": last_time.astimezone().strftime('%Y-%m-%d %H:%M:%S'),
                        "Delay": f"{diff.days}d {diff.seconds//3600}h {(diff.seconds%3600)//60}m",
                        "Status": status
                    })
                else:
                    results.append({
                        "Device Name": device_name,
                        "Variable (Key)": key,
                        "Last Update": "Never",
                        "Delay": "N/A",
                        "Status": "âšª No Data"
                    })
        except Exception as e:
            print(f"âš ï¸ Lá»—i khi quÃ©t {device_name}: {e}")
        return results

def parse_delay(delay_str):
    """
    Chuyá»ƒn Ä‘á»•i chuá»—i format (1s, 5m, 2h, 1d) sang giÃ¢y.
    """
    delay_str = delay_str.lower().strip()
    match = re.match(r"(\d+)\s*([smhd])?", delay_str)
    if not match:
        return 3600 # Máº·c Ä‘á»‹nh 1 giá» náº¿u nháº­p sai

    value, unit = match.groups()
    value = int(value)

    multipliers = {
        's': 1,
        'm': 60,
        'h': 3600,
        'd': 86400
    }
    return value * multipliers.get(unit, 1) # Máº·c Ä‘á»‹nh lÃ  giÃ¢y náº¿u khÃ´ng cÃ³ Ä‘Æ¡n vá»‹

def run_system_audit():
    print("--- Cáº¤U HÃŒNH QUÃ‰T Há»† THá»NG NEWSENSE ---")
    USER = input("TÃªn Ä‘Äƒng nháº­p: ")
    PASS = getpass.getpass("Máº­t kháº©u (sáº½ khÃ´ng hiá»ƒn thá»‹): ")
    BASE_URL = "https://newsense.viphap.com/api"

    print("\nNháº­p thá»i gian trá»… tá»‘i Ä‘a cho phÃ©p (VÃ­ dá»¥: 30s, 15m, 2h, 1d)")
    raw_delay = input("Thá»i gian delay: ")
    delay_seconds = parse_delay(raw_delay)

    scanner = NewsenseScanner(BASE_URL, USER, PASS)
    if not scanner.token: return

    print(f"\nðŸš€ Báº¯t Ä‘áº§u quÃ©t toÃ n bá»™ há»‡ thá»‘ng (NgÆ°á»¡ng: {delay_seconds} giÃ¢y)...")
    all_devices = scanner.get_all_devices()
    print(f"ðŸ“¦ TÃ¬m tháº¥y {len(all_devices)} thiáº¿t bá»‹.")

    all_report_data = []

    def process_device(device):
        keys = scanner.get_device_keys(device['id'])
        return scanner.get_latest_telemetry(device['id'], device['name'], keys, delay_seconds)

    with ThreadPoolExecutor(max_workers=10) as executor:
        futures = [executor.submit(process_device, d) for d in all_devices]
        for f in futures:
            all_report_data.extend(f.result())

    df_report = pd.DataFrame(all_report_data)

    if not df_report.empty:
        df_report = df_report.sort_values(by=["Status", "Last Update"], ascending=[True, False])

        print("\nðŸ“Š Báº¢NG Tá»”NG Há»¢P TRáº NG THÃI Há»† THá»NG")
        print(df_report.to_string(index=False))

        filename = f"System_Audit_{datetime.now().strftime('%Y%m%d_%H%M')}.xlsx"
        df_report.to_excel(filename, index=False)
        print(f"\nâœ… ÄÃ£ xuáº¥t bÃ¡o cÃ¡o chi tiáº¿t ra file: {filename}")
    else:
        print("âŒ KhÃ´ng tÃ¬m tháº¥y dá»¯ liá»‡u biáº¿n nÃ o Ä‘á»ƒ bÃ¡o cÃ¡o.")

if __name__ == "__main__":
    run_system_audit()

